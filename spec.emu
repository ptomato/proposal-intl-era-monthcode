<!DOCTYPE html>
<meta charset="utf8">
<pre class="metadata">
title: Intl era and monthCode Proposal
stage: 2
location: https://tc39.es/proposal-intl-era-monthcode/
copyright: true
contributors: Google, Ecma International
</pre>
<emu-biblio href="biblio.json"></emu-biblio>

<emu-clause id="sup-temporal-calendar-abstract-ops">
  <h1>Abstract Operations</h1>

  <emu-clause id="sec-temporal-calendardateadd" type="implementation-defined abstract operation">
    <h1>
      CalendarDateAdd (
        _calendar_: a calendar type,
        _isoDate_: an ISO Date Record,
        _duration_: a Date Duration Record,
        _overflow_: ~constrain~ or ~reject~,
      ): either a normal completion containing an ISO Date Record or a throw completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It adds _dateDuration_ to _isoDate_ using the years, months, and weeks reckoning of _calendar_.
        If addition of years or months results in a nonexistent date, depending on _overflow_ it will be coerced to an existing date or the operation will throw.
      </dd>
    </dl>
    <emu-alg>
      1. If _calendar_ is *"iso8601"*, then
        1. Let _intermediate_ be BalanceISOYearMonth(_isoDate_.[[Year]] + _duration_.[[Years]], _isoDate_.[[Month]] + _duration_.[[Months]]).
        1. Set _intermediate_ to ? RegulateISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _isoDate_.[[Day]], _overflow_).
        1. Let _d_ be _intermediate_.[[Day]] + _duration_.[[Days]] + 7 √ó _duration_.[[Weeks]].
        1. Let _result_ be BalanceISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _d_).
      1. Else,
        1. Let _result_ be an implementation-defined ISO Date Record, or throw a *RangeError* exception, as described below.
      1. If ISODateWithinLimits(_result_) is *false*, throw a *RangeError* exception.
      1. Return _result_.
    </emu-alg>
    <p>
      When _calendar_ is not *"iso8601"*, the operation performs implementation-defined processing to add _duration_ to _date_ in the context of the calendar represented by _calendar_ and returns the corresponding day, month and year of the result in the ISO 8601 calendar values as an ISO Date Record.
      It may throw a *RangeError* exception if _overflow_ is ~reject~ and the resulting month or day would need to be clamped in order to form a valid date in _calendar_.
    </p>
    <p><ins>For guidance on clamping a month or day, see the note in CalendarDateToISO.</ins></p>
  </emu-clause>

  <emu-clause id="sec-temporal-calendardatetoiso" type="implementation-defined abstract operation">
    <h1>
      CalendarDateToISO (
        _calendar_: a calendar type,
        _fields_: a Calendar Fields Record,
        _overflow_: ~constrain~ or ~reject~,
      ): either a normal completion containing an ISO Date Record or a throw completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It performs implementation-defined processing to convert _fields_, which represents either a date or a year and month in the built-in calendar identified by _calendar_, to a corresponding representative date in the ISO 8601 calendar, subject to overflow correction specified by _overflow_.
        For ~reject~, values that do not form a valid date cause an exception to be thrown, as described below.
        For ~constrain~, values that do not form a valid date are clamped to their respective valid range.
      </dd>
    </dl>
    <emu-alg>
      1. If _calendar_ is *"iso8601"*, then
        1. Assert: _fields_.[[Year]], _fields_.[[Month]], and _fields_.[[Day]] are not ~unset~.
        1. Return ? RegulateISODate(_fields_.[[Year]], _fields_.[[Month]], _fields_.[[Day]], _overflow_).
      1. Return an implementation-defined ISO Date Record, or throw a *RangeError* exception, as described below.
    </emu-alg>
    <p>Like RegulateISODate, the operation throws a *RangeError* exception when _overflow_ is ~reject~ and the date described by _fields_ does not exist.</p>
    <p>Clamping an invalid date to the correct range when _overflow_ is ~constrain~ is a behaviour specific to each calendar other than *"iso8601"*, but all calendars follow this guideline:</p>
    <ul>
      <li>Pick the closest day in the same month. If there are two equally-close dates in that month, pick the later one.</li>
      <li>
        <p>If the month is a leap month that doesn't exist in the year, pick another date according to the cultural conventions of that calendar's users. Usually this will result in the same day in the month before or after where that month would normally fall in a leap year.</p>
        <p><ins>Of the currently supported calendars, *"chinese"*, *"dangi"*, and *"hebrew"* use leap months. In the *"chinese"* and *"dangi"* calendars, when clamping a leap month in a year without a leap month, use the same day in the previous month (the month with the same month code, but without the *"L"* suffix.) In the *"hebrew"* calendar, clamp month *"M05L"* (Adar I) to *"M06"* (Adar).</ins></p>
      </li>
      <li>Otherwise, pick the closest date that is still in the same year. If there are two equally-close dates in that year, pick the later one.</li>
      <li>
        <p>If the entire year doesn't exist, pick the closest date in a different year. If there are two equally-close dates, pick the later one. <ins>This is not known to happen in any of the currently supported calendars.</ins></p>
      </li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-temporal-calendarsupportsera" type="abstract operation">
    <h1>
      CalendarSupportsEra (
        _calendar_: a String,
      ): a Boolean
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        The following algorithm refers to the era data from <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">UTS 35's Supplemental Calendar Data</a>.
      </dd>
    </dl>
    <emu-alg>
      1. If _calendar_ is listed in the Calendar column of <emu-xref href="#table-eras"></emu-xref>, return *true*.
      1. Return *false*.
    </emu-alg>
    <emu-table id="table-eras">
      <emu-caption>era aliases and range of eraYear</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Calendar</th>
            <th>Era</th>
            <th>Aliases</th>
            <th>Minimum eraYear</th>
            <th>Maximum eraYear</th>
          </tr>
        </thead>
        <tr>
          <td>*"buddhist"*</td>
          <td>*"be"*</td>
          <td></td>
          <td>*-‚àû*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"coptic"*</td>
          <td>*"am"*</td>
          <td></td>
          <td>*-‚àû*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"ethiopic"*</td>
          <td>*"am"*</td>
          <td>*"incar"*</td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"ethiopic"*</td>
          <td>*"aa"*</td>
          <td>*"mundi"*</td>
          <td>*-‚àû*<sub>ùîΩ</sub></td>
          <td>*5500*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"ethioaa"*</td>
          <td>*"aa"*</td>
          <td>*"mundi"*</td>
          <td>*-‚àû*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"gregory"*</td>
          <td>*"ce"*</td>
          <td>*"ad"*</td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"gregory"*</td>
          <td>*"bce"*</td>
          <td>*"bc"*</td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"hebrew"*</td>
          <td>*"am"*</td>
          <td></td>
          <td>*-‚àû*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"indian"*</td>
          <td>*"shaka"*</td>
          <td></td>
          <td>*-‚àû*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"islamic"*</td>
          <td>*"ah"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"islamic"*</td>
          <td>*"bh"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"islamic-civil"*</td>
          <td>*"ah"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"islamic-civil"*</td>
          <td>*"bh"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"islamic-rgsa"*</td>
          <td>*"ah"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"islamic-rgsa"*</td>
          <td>*"bh"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"islamic-tbla"*</td>
          <td>*"ah"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"islamic-tbla"*</td>
          <td>*"bh"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"islamic-umalqura"*</td>
          <td>*"ah"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"islamic-umalqura"*</td>
          <td>*"bh"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"japanese"*</td>
          <td>*"reiwa"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"japanese"*</td>
          <td>*"heisei"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*31*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"japanese"*</td>
          <td>*"showa"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*64*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"japanese"*</td>
          <td>*"taisho"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*15*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"japanese"*</td>
          <td>*"meiji"*</td>
          <td></td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*45*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"japanese"*</td>
          <td>*"ce"*</td>
          <td>*"ad"*</td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*1868*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"japanese"*</td>
          <td>*"bce"*</td>
          <td>*"bc"*</td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"persian"*</td>
          <td>*"ap"*</td>
          <td></td>
          <td>*-‚àû*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"roc"*</td>
          <td>*"roc"*</td>
          <td>*"minguo"*</td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
        <tr>
          <td>*"roc"*</td>
          <td>*"broc"*</td>
          <td>*"before-roc"*, *"minguo-qian"*</td>
          <td>*1*<sub>ùîΩ</sub></td>
          <td>*+‚àû*<sub>ùîΩ</sub></td>
        </tr>
      </table>
    </emu-table>
    <emu-note>
      The content in this table is proposed by Era Code WG to CLDR TC in <a href="https://github.com/unicode-org/cldr/pull/2665">PR 2665</a> and under review. It is targeted to be part of CLDR 43, scheduled to be released in April 2023.
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-temporal-canonicalizeeraincalendar" type="abstract operation">
    <h1>
      CanonicalizeEraInCalendar (
        _calendar_: a String,
        _era_: a String,
      ): a String or *undefined*
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        The following algorithm refers to the era data from <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">UTS 35's Supplemental Calendar Data</a>.
      </dd>
    </dl>
    <emu-alg>
      1. For each row of <emu-xref href="#table-eras"></emu-xref>, do
        1. Let _cal_ be the Calendar value of the current row.
        1. If _cal_ is equal to _calendar_, then
          1. Let _e_ be the Era value of the current row.
          1. If _e_ is equal to _era_, return _era_.
          1. Let _aliases_ be a List whose elements are the strings given in the Aliases column of the row.
          1. If _aliases_ contains _era_, return _era_.
      1. Return *undefined*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-isvalidmonthecodeforcalendar" type="abstract operation">
    <h1>
      IsValidMonthCodeForCalendar (
        _calendar_: a String,
        _monthCode_: a String,
      ): a Boolean
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. Let _commonMonthCodes_ be ¬´ *"M01"*, *"M02"*, *"M03"*, *"M04"*, *"M05"*, *"M06"*, *"M07"*, *"M08"*, *"M09"*, *"M10"*, *"M11"*, *"M12"* ¬ª.
      1. If _commonMonthCodes_ contains _monthCode_, return *true*.
      1. If _calendar_ is not listed in the Calendar column of <emu-xref href="#table-additional-month-codes"></emu-xref>, return *false*.
      1. Let _r_ be the row in <emu-xref href="#table-additional-month-codes"></emu-xref> which the _calendar_ is in the Calendar column.
      1. Let _specialMonthCodes_ be a List whose elements are the strings given in the *"Additional Month Codes"* column of _r_.
      1. If _specialMonthCodes_ contains _monthCode_, return *true*.
      1. Return *false*.
    </emu-alg>

    <emu-table id="table-additional-month-codes">
      <emu-caption>Additional Month Codes in Calendars</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Calendar</th>
            <th>Additional Month Codes</th>
          </tr>
        </thead>
        <tr>
          <td>*"chinese"*</td>
          <td>*"M01L"*, *"M02L"*, *"M03L"*, *"M04L"*, *"M05L"*, *"M06L"*, *"M07L"*, *"M08L"*, *"M09L"*, *"M10L"*, *"M11L"*, *"M12L"*</td>
        </tr>
        <tr>
          <td>*"coptic"*</td>
          <td>*"M13"*</td>
        </tr>
        <tr>
          <td>*"dangi"*</td>
          <td>*"M01L"*, *"M02L"*, *"M03L"*, *"M04L"*, *"M05L"*, *"M06L"*, *"M07L"*, *"M08L"*, *"M09L"*, *"M10L"*, *"M11L"*, *"M12L"*</td>
        </tr>
        <tr>
          <td>*"ethiopic"*</td>
          <td>*"M13"*</td>
        </tr>
        <tr>
          <td>*"ethioaa"*</td>
          <td>*"M13"*</td>
        </tr>
        <tr>
          <td>*"hebrew"*</td>
          <td>*"M05L"*</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-isvaliderayearforcalendar" type="abstract operation">
    <h1>
      IsValidEraYearForCalendar (
        _calendar_: a String,
        _era_: a String,
        _eraYear_: a integer,
      ): a Boolean
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        The following algorithm refers to the era data from <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">UTS 35's Supplemental Calendar Data</a>.
      </dd>
    </dl>
    <emu-alg>
      1. Let _era_ be CanonicalizeEraInCalendar(_calendar_, _era_).
      1. If _era_ is *undefined*, return *false*.
      1. Let _r_ be the row in <emu-xref href="#table-eras"></emu-xref> which the _calendar_ is in the Calendar column and the _era_ is in the Era column.
      1. Let _min_ be the value given in the *"Minimum eraYear"* column of _r_.
      1. Let _max_ be the value given in the *"Maximum eraYear"* column of _r_.
      1. If _eraYear_ &lt; _min_, return *false*.
      1. If _eraYear_ > _max_, return *false*.
      1. Return *true*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sup-temporal-calendar-date-records">
    <h1>Calendar Date Records</h1>
    <p>
      A <dfn variants="Calendar Date Records">Calendar Date Record</dfn> is a Record value used to represent a valid calendar date in a non-ISO 8601 calendar.
      Calendar Date Records are produced by the abstract operation CalendarISOToDate.
    </p>
    <p>Calendar Date Records have the fields listed in <emu-xref href="#table-temporal-calendar-date-record-fields"></emu-xref>.</p>
    <p>This definition supersedes the one in <emu-xref href="#sec-temporal-calendar-date-records"></emu-xref>.</p>
    <emu-table id="table-temporal-calendar-date-record-fields" caption="Calendar Date Record Fields">
      <table class="real-table">
        <tr>
          <th>Field Name</th>
          <th>Value</th>
          <th>Meaning</th>
        </tr>
        <tr>
          <td>[[Era]]</td>
          <td>a String or *undefined*</td>
          <td>
            A lowercase String value representing the date's era, or *undefined* for calendars that do not have eras.<br>
            The value of this field for a calendar with the identifier _calendar_ should be the result of calling CalendarDateEra(_calendar_, _date_), where _date_ is a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
          </td>
        </tr>
        <tr>
          <td>[[EraYear]]</td>
          <td>an integer or *undefined*</td>
          <td>
            The ordinal position of the date's year within its era, or *undefined* for calendars that do not have eras.<br>
            The value of this field for a calendar with the identifier _calendar_ should be the result of calling CalendarDateEraYear(_calendar_, _date_), where _date_ is a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
            <emu-note>
              Era years are 1-indexed for many calendars, but not all (e.g., the eras of the Burmese calendar each start with a year 0). Years can also advance opposite the flow of time (as for BCE years in the Gregorian calendar).
            </emu-note>
          </td>
        </tr>
        <tr>
          <td>[[Year]]</td>
          <td>an integer</td>
          <td>
            The date's year relative to the first day of a calendar-specific "epoch year".<br>
            The value of this field for a calendar with the identifier _calendar_ should be the result of calling CalendarDateArithmeticYear(_calendar_, _date_), where _date_ is a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
            <emu-note>The year is relative to the first day of the calendar's epoch year, so if the epoch era starts in the middle of the year, the year will be the same value before and after the start date of the era.</emu-note>
          </td>
        </tr>
        <tr>
          <td>[[Month]]</td>
          <td>a positive integer</td>
          <td>
            The 1-based ordinal position of the date's month within its year.
            <emu-note>
              When the number of months in a year of the calendar is variable, a different value can be returned for dates that are part of the same month in different years. For example, in the Hebrew calendar, 1 Nisan 5781 is associated with value 7 while 1 Nisan 5782 is associated with value 8 because 5782 is a leap year and Nisan follows the insertion of Adar I.
            </emu-note>
          </td>
        </tr>
        <tr>
          <td>[[MonthCode]]</td>
          <td>a String</td>
          <td>
            The month code of the date's month. The month code for a month that is not a leap month and whose 1-based ordinal position in a common year of the calendar (i.e., a year that is not a leap year) is _n_ should be the string-concatenation of *"M"* and ToZeroPaddedDecimalString(_n_, 2), and the month code for a month that is a leap month inserted after a month whose 1-based ordinal position in a common year of the calendar is _p_ should be the string-concatenation of *"M"*, ToZeroPaddedDecimalString(_p_, 2), and *"L"*.
            <emu-note>
              For example, in the Hebrew calendar, the month code of Adar (and Adar II, in leap years) is *"M06"* and the month code of Adar I (the leap month inserted before Adar II) is *"M05L"*. In a calendar with a leap month at the start of some years, the month code of that month would be *"M00L"*.
            </emu-note>
          </td>
        </tr>
        <tr>
          <td>[[Day]]</td>
          <td>a positive integer</td>
          <td>
            The 1-based ordinal position of the date's day within its month.
          </td>
        </tr>
        <tr>
          <td>[[DayOfWeek]]</td>
          <td>a positive integer</td>
          <td>
            The day of the week corresponding to the date. The value should be 1-based, where 1 is the day corresponding to Monday in the given calendar.
          </td>
        </tr>
        <tr>
          <td>[[DayOfYear]]</td>
          <td>a positive integer</td>
          <td>
            The 1-based ordinal position of the date's day within its year.
          </td>
        </tr>
        <tr>
          <td>[[WeekOfYear]]</td>
          <td>a Year-Week Record</td>
          <td>
            <p>The date's <em>calendar week of year</em>, and the corresponding <em>week calendar year</em>.</p>
            <p>The Year-Week Record's [[Week]] field should be 1-based.</p>
            <p>The Year-Week Record's [[Year]] field is relative to the first day of a calendar-specific "epoch year", as in the Calendar Date Record's [[Year]] field, not relative to an era as in [[EraYear]].</p>
            <p>
              Usually the Year-Week Record's [[Year]] field will contain the same value as the Calendar Date Record's [[Year]] field, but may contain the previous or next year if the week number in the Year-Week Record's [[Week]] field overlaps two different years.
              See also ISOWeekOfYear.
            </p>
            <p>The Year-Week Record contains *undefined* in [[Week]] and [[Year]] field for calendars that do not have a well-defined week calendar system.</p>
          </td>
        </tr>
        <tr>
          <td>[[DaysInWeek]]</td>
          <td>a positive integer</td>
          <td>The number of days in the date's week.</td>
        </tr>
        <tr>
          <td>[[DaysInMonth]]</td>
          <td>a positive integer</td>
          <td>The number of days in the date's month.</td>
        </tr>
        <tr>
          <td>[[DaysInYear]]</td>
          <td>a positive integer</td>
          <td>The number of days in the date's year.</td>
        </tr>
        <tr>
          <td>[[MonthsInYear]]</td>
          <td>a positive integer</td>
          <td>The number of months in the date's year.</td>
        </tr>
        <tr>
          <td>[[InLeapYear]]</td>
          <td>a Boolean</td>
          <td>
            *true* if the date falls within a leap year, and *false* otherwise.
            <emu-note>
              A "leap year" is a year that contains more days than other years (for solar or lunar calendars) or more months than other years (for lunisolar calendars like Hebrew or Chinese).
              Some calendars, especially lunisolar ones, have further variation in year length that is not represented in the output of this operation (e.g., the Hebrew calendar includes common years with 353, 354, or 355 days and leap years with 383, 384, or 385 days).
            </emu-note>
          </td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-calendardateera" type="abstract operation">
    <h1>
      CalendarDateEra (
        _calendar_: a String,
        _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
      ): a String or *undefined*
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns a lowercase String value representing that era, or *undefined* for calendars that do not have eras.</dd>
    </dl>
    <emu-alg>
      1. If CalendarSupportsEra(_calendar_) is *false*, return *undefined*.
      1. Let _era_ be the String to indicate the era corresponding to _date_ in the context of the calendar represented by _calendar_ from an implementation-defined processing.
      1. Return CanonicalizeEraInCalendar(_calendar_, _era_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-calendardateerayear" type="abstract operation">
    <h1>
      CalendarDateEraYear (
        _calendar_: a String,
        _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
      ): an integer or *undefined*
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the ordinal position of the year of _date_ in that era, or *undefined* for calendars that do not have eras.</dd>
    </dl>
    </dl>
    <emu-alg>
      1. If CalendarSupportsEra(_calendar_) is *false*, return *undefined*.
      1. Let _eraYear_ be the integer to indicate the era year corresponding to _date_ in the context of the calendar represented by _calendar_ from an implementation-defined processing.
      1. Assert: _eraYear_ is an integer.
      1. Return _eraYear_.
    </emu-alg>
    <emu-note>
      Era years are 1-indexed for many calendars, but not all (e.g., the eras of the Burmese calendar each start with a year 0). Years can also advance opposite the flow of time (as for BCE years in the Gregorian calendar).
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-temporal-calendardatearithmeticyear" type="abstract operation">
    <h1>
      CalendarDateArithmeticYear (
        _calendar_: a calendar type that is not *"iso8601"*,
        _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
      ): an integer
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It performs implementation-defined processing to find the year for the date corresponding to _date_ in the context of the calendar represented by _calendar_ relative to a well-defined epoch year for that calendar.</dd>
    </dl>
    <emu-alg>
      1. Let _year_ be _date_.[[ISOYear]].
      1. Let _r_ be the row in <emu-xref href="#table-epoch-years"></emu-xref> which the value of the Calendar column is _calendar_.
      1. Let _epochYear_ be the value given in the *"Epoch ISO Year"* column of _r_.
      1. Let _arithmeticYear_ be the number of whole years in the calendar represented by _calendar_ elapsed until the ISO year _year_ since the calendar year that started during ISO year _epochYear_, according to implementation-defined processing.
      1. Return _arithmeticYear_.
    </emu-alg>

    <emu-table id="table-epoch-years">
      <emu-caption>epoch years</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Calendar</th>
            <th>Epoch ISO Year</th>
          </tr>
        </thead>
        <tr>
          <td>*"buddhist"*</td>
          <td>-543</td>
        </tr>
        <tr>
          <td>*"chinese"*</td>
          <td>0</td>
        </tr>
        <tr>
          <td>*"coptic"*</td>
          <td>283</td>
        </tr>
        <tr>
          <td>*"dangi"*</td>
          <td>0</td>
        </tr>
        <tr>
          <td>*"ethiopic"*</td>
          <td>7</td>
        </tr>
        <tr>
          <td>*"ethioaa"*</td>
          <td>-5492</td>
        </tr>
        <tr>
          <td>*"gregory"*</td>
          <td>0</td>
        </tr>
        <tr>
          <td>*"hebrew"*</td>
          <td>-3761</td>
        </tr>
        <tr>
          <td>*"indian"*</td>
          <td>78</td>
        </tr>
        <tr>
          <td>*"islamic"*</td>
          <td>621</td>
        </tr>
        <tr>
          <td>*"islamic-civil"*</td>
          <td>621</td>
        </tr>
        <tr>
          <td>*"islamic-rgsa"*</td>
          <td>621</td>
        </tr>
        <tr>
          <td>*"islamic-tbla"*</td>
          <td>621</td>
        </tr>
        <tr>
          <td>*"islamic-umalqura"*</td>
          <td>621</td>
        </tr>
        <tr>
          <td>*"japanese"*</td>
          <td>0</td>
        </tr>
        <tr>
          <td>*"persian"*</td>
          <td>621</td>
        </tr>
        <tr>
          <td>*"roc"*</td>
          <td>1911</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sup-temporal-calendarextrafields" type="implementation-defined abstract operation">
    <h1>
      CalendarExtraFields (
        _calendar_: a calendar type,
        _fields_: a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>,
      ): a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It characterizes calendar-specific fields that are relevant for the provided _fields_ in the built-in calendar identified by _calendar_.</dd>
    </dl>
    <p>This definition supersedes the definition provided in TemporalCalendarExtraFields.</p>
    <emu-alg>
      1. If _fields_ contains an element equal to ~year~ and CalendarSupportsEra(_calendar_) is *true*, then
        1. Append ~era~ and ~era-year~ to _fields_.
      1. Return _fields_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sup-temporal-calendarfieldkeystoignore" type="implementation-defined abstract operation">
    <h1>
      CalendarFieldKeysToIgnore (
        _calendar_: a calendar type,
        _keys_: a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>,
      ): a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It determines which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the given _calendar_.
        A field always invalidates at least itself.
      </dd>
    </dl>
    <p>This definition supersedes the definition provided in TemporalCalendarFieldKeysToIgnore.</p>
    <emu-alg>
      1. Let _ignoredKeys_ be an empty List.
      1. For each element _key_ of _keys_, do
        1. If _key_ is ~month~, append ~month-code~ to _ignoredKeys_.
        1. Else if _key_ is ~month-code~, append ~month~ to _ignoredKeys_.
        1. If _key_ is one of ~era~, ~era-year~, or ~year~ and CalendarSupportsEra(_calendar_) is *true*, then
          1. Append ~era~, ~era-year~, and ~year~ to _ignoredKeys_.
        1. Else,
          1. Append _key_ to _ignoredKeys_.
      1. NOTE: While _ignoredKeys_ can have duplicate elements, this is not intended to be meaningful. This specification only checks whether particular keys are or are not members of the list.
      1. Return _ignoredKeys_.
    </emu-alg>
  </emu-clause>
</emu-clause>
